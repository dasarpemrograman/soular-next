# 5.1 Arsitektur Implementasi

## 1. Arsitektur Sistem

Soular Next dibangun dengan arsitektur modern berbasis client-server yang memanfaatkan teknologi web terkini. Sistem ini mengadopsi pendekatan **full-stack** dengan pemisahan yang jelas antara frontend, backend, dan database layer untuk memastikan skalabilitas dan maintainability yang optimal.

Arsitektur aplikasi menggunakan pola **Server-Side Rendering (SSR)** dan **Client-Side Rendering (CSR)** hybrid yang disediakan oleh Next.js 14. Pendekatan ini memungkinkan halaman-halaman krusial seperti landing page dan detail film di-render di sisi server untuk optimasi SEO dan performa loading awal, sementara komponen interaktif seperti komentar, favorit, dan sistem subscription menggunakan client-side rendering untuk pengalaman pengguna yang lebih responsif.

Sistem autentikasi dan otorisasi dikelola secara terpusat melalui Supabase Auth yang terintegrasi dengan database PostgreSQL. Setiap request yang memerlukan autentikasi akan melalui middleware Next.js yang memvalidasi session token sebelum mengakses protected routes. Untuk keamanan data, sistem menerapkan **Row Level Security (RLS)** di level database, memastikan bahwa setiap user hanya dapat mengakses data yang sesuai dengan role dan permission mereka.

Arsitektur subscription dan premium content diimplementasikan dengan sistem berbasis role-based access control (RBAC) yang membedakan empat tier pengguna: Free, Basic, Premium, dan Pro. Setiap tier memiliki akses berbeda terhadap konten dan fitur aplikasi, yang dikontrol melalui kombinasi database policies dan middleware checks di aplikasi layer.

Untuk menangani real-time features seperti notifikasi dan update data, sistem memanfaatkan Supabase Realtime yang berbasis PostgreSQL's LISTEN/NOTIFY mechanism. Hal ini memungkinkan fitur seperti live comment updates dan notification system tanpa perlu polling database secara terus-menerus.

## 2. Tech Stack

### Frontend Layer
Platform Soular Next dibangun menggunakan **Next.js 14** dengan **App Router** sebagai framework utama. Next.js dipilih karena kemampuannya dalam server-side rendering, automatic code splitting, dan optimasi performa yang superior. Framework ini juga menyediakan file-based routing yang intuitif dan mendukung React Server Components untuk mengurangi JavaScript bundle size yang dikirim ke client.

Untuk styling dan user interface, aplikasi menggunakan kombinasi **Tailwind CSS** dan **shadcn/ui**. Tailwind CSS menyediakan utility-first approach yang memudahkan rapid development dan konsistensi desain, sementara shadcn/ui memberikan komponen-komponen pre-built yang fully customizable dan accessible. Komponen UI seperti Dialog, Card, Button, dan Form semuanya dibangun di atas Radix UI primitives yang memastikan accessibility standards (WCAG) terpenuhi.

Untuk animasi dan micro-interactions, aplikasi mengintegrasikan **Framer Motion** yang memberikan pengalaman visual yang smooth dan engaging. Library ini digunakan untuk page transitions, hover effects, dan animated components seperti modal dialogs dan dropdown menus.

State management di aplikasi ini menggunakan kombinasi **React Hooks** (useState, useEffect, useContext) untuk local state dan **custom hooks** untuk logic reusability. Untuk data fetching dan caching, sistem menggunakan native fetch API yang dikombinasikan dengan Next.js caching mechanisms dan Supabase client yang sudah built-in dengan optimistic updates.

Validasi form menggunakan **Zod** untuk type-safe schema validation, yang terintegrasi dengan **React Hook Form** untuk form state management. Kombinasi ini memastikan data validation terjadi di client-side sebelum dikirim ke server, mengurangi unnecessary network requests.

### Backend Layer
Backend API dibangun menggunakan **Next.js API Routes** yang berjalan di Node.js runtime. Setiap endpoint didefinisikan sebagai route handlers yang menghandle HTTP methods (GET, POST, PATCH, DELETE) sesuai dengan RESTful conventions. API routes ini berfungsi sebagai middleware layer antara frontend dan database, menangani business logic, validation, dan authorization.

**Supabase** berfungsi sebagai Backend-as-a-Service (BaaS) yang menyediakan database PostgreSQL, authentication, storage, dan real-time subscriptions dalam satu platform terintegrasi. Supabase dipilih karena developer experience yang excellent, built-in security features (RLS), dan kemudahan scaling.

Untuk autentikasi, sistem menggunakan **Supabase Auth** yang mendukung berbagai authentication providers (email/password, Google OAuth, GitHub, dll). Session management menggunakan JWT tokens yang disimpan dalam HTTP-only cookies untuk mencegah XSS attacks.

File uploads dan media management dihandle oleh **Supabase Storage** dengan automatic image optimization dan CDN delivery. Storage buckets dikonfigurasi dengan access policies yang memastikan hanya authorized users yang dapat upload atau akses file tertentu.

Untuk handling payments dan subscriptions (dalam mode demo), sistem sudah dipersiapkan dengan struktur yang mendukung integrasi dengan **Stripe** atau payment gateways lainnya. Transaction logs dan subscription status disimpan di database untuk audit trail dan reconciliation.

### Database Layer
Database menggunakan **PostgreSQL 15** yang disediakan oleh Supabase. PostgreSQL dipilih karena robustness, ACID compliance, dan dukungan untuk advanced features seperti full-text search, JSONB columns, dan triggers.

Database schema didesain dengan normalization principles untuk menghindari data redundancy sambil tetap mempertimbangkan query performance. Tabel-tabel utama seperti `profiles`, `films`, `events`, `forums`, dan `subscription_plans` memiliki foreign key constraints yang menjaga referential integrity.

**Row Level Security (RLS)** policies diterapkan di semua tabel untuk memastikan data isolation antar users. Setiap query secara otomatis di-filter berdasarkan authenticated user's ID dan role, mencegah unauthorized data access bahkan jika ada bug di application layer.

Database functions dan stored procedures digunakan untuk complex business logic seperti `get_user_subscription()`, `has_premium_access()`, dan `get_film_comments()`. Pendekatan ini mengurangi round-trips ke database dan memastikan logic consistency.

Indexing strategy diterapkan pada kolom-kolom yang sering di-query seperti `email`, `username`, `slug`, dan foreign keys untuk optimasi query performance. Full-text search indexes menggunakan PostgreSQL's `tsvector` dan `pg_trgm` extension untuk pencarian film dan forum posts.

### Development Tools
Development workflow menggunakan **TypeScript** untuk type safety dan better developer experience. Type definitions membantu catch errors saat compile time dan memberikan autocomplete yang comprehensive di IDE.

Code quality dijaga dengan **ESLint** dan **Prettier** yang dikonfigurasi sesuai Next.js best practices. Pre-commit hooks menggunakan Husky memastikan code formatting dan linting checks berjalan sebelum code di-commit ke repository.

Version control menggunakan **Git** dengan branching strategy yang terorganisir. Deployment dilakukan melalui **Vercel** yang menyediakan automatic deployments, preview environments untuk setiap pull request, dan global CDN distribution.

## 3. Database Schema

### Tabel Utama

#### profiles
Tabel `profiles` menyimpan informasi pengguna yang extend dari Supabase Auth users. Setiap kali user baru melakukan sign up, trigger `on_auth_user_created` secara otomatis membuat record di tabel ini. Tabel ini berisi data seperti `name`, `username` (unique), `email`, `avatar`, `bio`, dan `role` (user/moderator/admin). Kolom `is_banned` dan `ban_expires_at` mengontrol akses pengguna yang melanggar terms of service. Untuk subscription system, tabel ini memiliki kolom `subscription_plan`, `subscription_status`, dan `subscription_ends_at` yang di-sync dengan tabel `user_subscriptions` melalui trigger.

#### films
Tabel `films` adalah core content table yang menyimpan informasi film dokumenter. Struktur mencakup `title`, `slug` (untuk SEO-friendly URLs), `description`, `director`, `year`, `duration` (dalam menit), `category` (dengan constraint check untuk kategori valid), dan `youtube_url` untuk embedded video. Kolom `thumbnail` menyimpan URL poster film yang di-host di Supabase Storage atau external CDN. Flag `is_premium` menandai film yang memerlukan subscription, sementara `is_published` mengontrol visibility. Kolom `rating` dan `view_count` di-update secara otomatis melalui aggregation functions.

#### events
Tabel `events` mengelola acara-acara komunitas dengan informasi seperti `title`, `slug`, `description`, `host_id` (foreign key ke profiles), `location`, `date`, `end_date`, dan `max_participants`. Kolom `event_type` (online/offline/hybrid) menentukan format acara. Status event dikontrol oleh `is_published` flag. Tabel ini berelasi dengan `event_registrations` untuk tracking peserta.

#### event_registrations
Tabel relasional yang menghubungkan users dengan events yang mereka ikuti. Berisi `user_id`, `event_id`, dan `status` (registered/attended/cancelled/waitlist). Trigger `update_event_participant_count` secara otomatis mengupdate jumlah peserta di tabel events ketika ada perubahan registration.

#### forums dan forum_posts
Struktur dua-level untuk discussion forums. Tabel `forums` menyimpan kategori forum seperti "General Discussion", "Film Reviews", dll dengan informasi `name`, `slug`, `description`, dan statistik (`post_count`, `topic_count`). Tabel `forum_posts` berisi actual posts dengan support untuk threading (kolom `parent_id` untuk replies). Setiap post mencatat `author_id`, `content`, `is_pinned`, `is_locked`, dan engagement metrics.

#### favorites
Tabel junction sederhana untuk many-to-many relationship antara users dan films. Primary key composite (`user_id`, `film_id`) memastikan user tidak bisa favorite film yang sama dua kali. Trigger `update_film_favorite_count` otomatis mengupdate favorite counter di tabel films.

### Tabel Subscription System

#### subscription_plans
Master table untuk subscription tiers yang mendefinisikan `name` (free/basic/premium/pro), `display_name`, `description`, `price_monthly`, `price_yearly`, dan `features` (JSONB array). Kolom `max_downloads`, `max_offline_films`, `ad_free`, `early_access`, `exclusive_content`, dan `priority_support` mendefinisikan capabilities setiap tier. Field `is_active` dan `sort_order` mengontrol availability dan display order.

#### user_subscriptions
Menyimpan subscription aktif setiap user dengan informasi `user_id`, `plan_id`, `status` (active/cancelled/expired/past_due/trialing), `billing_cycle` (monthly/yearly), dan timestamp fields (`started_at`, `current_period_start`, `current_period_end`). Kolom `cancel_at_period_end` dan `cancelled_at` menangani subscription cancellations. Constraint UNIQUE pada `user_id` memastikan satu user hanya punya satu active subscription.

#### payment_transactions
Audit log untuk semua transaksi pembayaran yang mencatat `user_id`, `subscription_id`, `amount`, `currency`, `status`, `payment_method`, `payment_provider`, dan `transaction_reference`. Kolom `metadata` (JSONB) menyimpan additional payment details. Tabel ini crucial untuk reconciliation dan dispute resolution.

#### premium_content
Junction table yang mendefinisikan content mana yang requires premium access. Berisi `content_type` (film/collection/event/article), `content_id`, `required_plan` (minimum tier yang diperlukan), `preview_duration` (detik preview untuk free users), dan flag `is_early_access` dengan `early_access_until` timestamp untuk time-limited exclusivity.

### Tabel Komentar dan Engagement

#### film_comments
Sistem komentar untuk films dengan struktur `user_id`, `film_id`, `content`, `rating` (1-5 stars), dan `parent_id` untuk threaded replies. Index pada `film_id` dan `created_at` mengoptimalkan query untuk loading comments. Soft delete menggunakan flag `is_deleted` untuk moderation purposes.

#### film_comment_likes
Tracking likes pada comments dengan composite primary key (`user_id`, `comment_id`). Trigger `update_comment_like_count` automatically maintains like counter di tabel `film_comments`.

### Tabel Moderasi

#### moderation_logs
Comprehensive audit trail untuk semua moderasi actions yang dilakukan oleh moderators/admins. Mencatat `moderator_id`, `action_type` (ban_user/unban_user/role_changed/delete_content/etc), `target_type`, `target_id`, `reason`, dan `metadata` (JSONB untuk additional context). Tabel ini immutable (INSERT only) untuk integrity.

### Database Functions & Triggers

Sistem menggunakan berbagai PostgreSQL functions untuk business logic:

- **Authentication Triggers**: `handle_new_user()` otomatis membuat profile saat user sign up dengan auto-generated unique username
- **Timestamp Triggers**: `handle_updated_at()` otomatis update `updated_at` column di semua tabel
- **Counter Triggers**: Berbagai triggers untuk maintain denormalized counts (view_count, favorite_count, comment_count, etc.)
- **Access Control Functions**: `has_premium_access()`, `is_premium_content()` untuk authorization checks
- **Aggregation Functions**: `get_film_comments()`, `get_film_average_rating()` untuk efficient data retrieval
- **Subscription Functions**: `cancel_subscription()`, `reactivate_subscription()`, `get_user_subscription()` untuk subscription management

### Indexing Strategy

Indexes strategis diterapkan untuk query optimization:
- B-tree indexes pada foreign keys dan frequently queried columns (username, email, slug)
- GiN indexes untuk full-text search pada `films.title` dan `films.description` menggunakan `tsvector`
- Partial indexes pada boolean flags (contoh: `WHERE is_published = true`)
- Composite indexes pada query patterns yang umum (contoh: `(film_id, created_at)` pada comments)

### Row Level Security (RLS)

Setiap tabel dilindungi dengan RLS policies yang granular:
- **Public Read**: Films, events, forums dapat dibaca semua orang
- **Authenticated Write**: Users dapat create/update data mereka sendiri
- **Owner Control**: Users hanya bisa edit/delete content yang mereka buat
- **Admin Override**: Admin role dapat bypass restrictions untuk moderation
- **Subscription Enforcement**: Premium content checks di database level

Schema ini didesain dengan prinsip normalization untuk data integrity sambil menggunakan selective denormalization (counter fields) untuk query performance optimization.